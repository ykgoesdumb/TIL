# 14. 가상 메모리

## 14-1 연속 메모리 할당
- 연속 메모리 할당 : 프로세스에 연속적인 메모리 공간을 할당

### 스와핑
- 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역 (스왑영역) 으로 쫓아내고
- 그렇게 생긴 빈 공간에 새 프로세스 적재
- 지금 당장 사용되는 프로세스만 메모리에 적재
- 스왑 아웃
  - 사용되지 않는 프로세스를 보조기억장치로 쫓아내는 단계
- 스왑 인
  - 스왑 아웃된 프로세스를 다시 메모리로 

### 스와핑의 이점
- 프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기 가 가능
- 실제 물리 메모리보다 큰 프로세스들을 동시에 실행 가능 (스왑 인 아웃 반복)


### 스왑 영역  크기 확인하기 

```
free -h

top
```

### 메모리 할당
프로세스는 메모리의 빈공간에 할당 되어야 함

-> 빈공간이 여러 개 있다면?

- 최초 적합 (first fit)
  - 빈공간 순서대로 검색하다 적재할 수 있는 공간 발견하면 프로세스 방식
  - 검색 최소화 빠른 할당
- 최적 적합 (best fit)
  - 빈공간 모두 검색한뒤 적재 가능한 가장 작은 공간에 할당
- 최악 적합 (worst fit)
  - 운영체제 빈공간 모두 검색한뒤 적재 가능한 가장 큰 공간에 할당


### 외부 단편화
- 사실 프로세스를 연속적으로 메모리에 할당하는 방식 비효율
- external fragmentation 외부 단편화 발생
  - 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
- 빈공간의 총합이 커도 메모리 사이사이에 빈공간 발생

### 외부 단편화 해결

1. 메모리 압축 (compaction)
- 여기저기 흩어져있는 빈공간들을 하나로 모으는 방식
  - 프로세스 적당히 재배치
  - 부작용이 있음
  - 빈공간을 하나로 합치는 과정, 재배치 하는 과정에서 오버헤드 발생, 프로세스들에게 영향이감
  - 최소한의 오버헤드를 발생하는 방식이 특정되어있지 않음

2. 페이징
- 양이 많으므로 다음 챕터에서 진행

---
## 14-2 페이징을 통한 가상 메모리 관리

- 연속 메모리 할당 문제점
  - 외부 단편화
  - 물리 메모리보다 큰 프로세스 실행 불가

> 페이징은 가상 메모리 관리 기법이다

- 가상 메모리는 
  - 적재할 프로세스 가 필요한 자원의 일부만 적재하여 진행시키는 기술
  - 실제 물리 메모리 크기보다 더 큰 프로세스 진행 가능
  - 페이징, 세그멘테이션
- 페이징이란?
  - 프로세스를 일정 크기로 자르고 메모리에 불 연속적으로 할당할 수 있다면?
  - 프로세스의 논리 주소 공간을 page 라는 일정 단위로 자름
  - 메모리의 물리 주소 공간을 frame 이라는 페이지와 동일한 일정한 단위로 자른뒤
  - 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이징 에서의 스와핑
  - 잘게 쪼개진 스와핑이라고 볼 수 있음
  - 페이지 인 (페이징 스왑 인)
  - 페이지 아웃 (페이징 스왑 아웃)
  - 프로세스를 이루고 있는 모든 페이지가 메모리내에 위치할 필요 없음

![img src](https://user-images.githubusercontent.com/49462767/226153090-1af89f45-4ed6-4e2d-af8b-f48e063d7dc6.png)

- 페이징 문제
  - 프로세스를 이루는 페이지가 어느 프레임에 적재되어있는가?
  - 프로세스가 메모리에 불연속적으로 배치되어있다면 CPU 입장에서 순차적으로 실행할 수 없음
  - CPU 입장에서 다음에 실행할 명령어 위치 찾기 어려움

- 페이지 테이블
  - 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
  - 물리주소에 불연속적 배치더라도 논리 주소에는 연속적으로 배치되도록 하는 방법
  - CPU 는 그냥 논리주소 순차적으로 실행

![img src](https://user-images.githubusercontent.com/49462767/226153237-777bb198-52ec-47f4-8702-0f49392611ae.png)
  
- 페이지 테이블의 내부 단편화
  - 외부단편화를 해결한 페이징이지만
  - 하나의 페이지보다 작은 크기로 발생하는 낭비

```bash
getconf PAGESIZE
16384
```

### PTBR
- 프로세스마다 페이지 테이블 있음
- 각 페이지 테이블은 CPU 내의 프로세스 테이블 베이스 레지스터 가 가리킴

![img src](https://user-images.githubusercontent.com/49462767/226153401-0d067bf9-01db-44fc-b02a-25ab4e09113c.png)


- 페이지 테이블이 메모리에 다 저장되어있는것이 좋은 건가?
- 메모리 접근시간 두배
  - 페이지 테이블 참조하기 위해 한번
  - 페이지 참조하기 한번


### TLB

- CPU 옆에 페이지 테이블의 캐시 메모리
- 불필요한 메모리 접근 줄임
- 페이지 테이블의 일부를 가져와 저장 (정확률 히트 레이트 존재)
  - TLB 히트 (메모리 접근 한번)
  - TLB 미스 (메모리 접근 두번)

### 페이징에서 주소 변환
- 특정 주소 접근
  - 어떤 페이지/프레임에 접근하고 싶은가?
  - 접근하려는 주소가 페이지, 프레임으로부터 얼마나 떨어져 있는지?

- 페이징 시스템의 논리주소
  - page number
  - offset (변위)
- (페이지번호, 변위) -> 페이지 테이블 -> (프레임번호, 변위)
  - 페이지 번호의 변위와 프레임번호의 변위는 같다


### 페이지 테이블 엔트리 (PTE)
- 페이지 테이블의 각각의 행
- 여기엔 아래와 같은 정보들이 담김
  - 페이지 번호
  - 프레임 번호
  - 유효비트   
    - 현재 해당페이지에 접근 가능한지 1 과 0 으로 나타냄
    - 메모리에 적재되었다면 1, 아니라면 0
    - 0인 페이지에 접근하려고 하면
      - page fault 인터럽트 발생
      - cpu 기존의 작업 백업
      - 페이지 폴트 처리루틴 실행 -> 원하는 페이지를 메모리로 가져온뒤 유효 비트 1로 변경
      - 페이지 폴트 처리 되면 CPU 해당 페이지 접근 할 수 있음
  - 보호비트
    - 페이지 보호 기능을 위해 존재하는 비트
    - r/w/x 
    - 페이지에 접근 권한을 제한 하여 페이지를 보호
  - 참조비트
    - cpu 가 이 페이지에 접근한 적이 있는지 여부
  - 더티비트 (수정 비트)
    - CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
    - 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기작업을 해야하는지 할 필요가 없는지 판단
    - 수정된 페이지는 스왑 아웃 될때 보조기억장치에도 쓰기 작업을 거쳐야 한다


---

## 14-2-1 추가 페이징의 이점 + 계층적 페이징

### 쓰기 시 복사 (copy on write)
- fork
  - 부모 프로세스 복제본 -> 자식 프로세스
  - 프로세스는 기본적으로 자원 공유 안함
  - 프로세스 생성 시간 지연, 메모리 낭비
    - 동일한 내용의 프로세스가 메모리를 두배로 잡아먹는 꼴
- copy on write
  - 부모 프로세스 fork 시 쓰기 작업이 없다면 부모 프로세스와 동일한 프레임을 가르킴
  - fork 의 자원 낭비를 효율적으로 바꿈

![img src](https://user-images.githubusercontent.com/49462767/226156633-398539a0-dc5e-4edf-94c1-475d675ed40f.png)

- 부모 프로세스 / 자식 프로세스중 하나가 페이지에 쓰기 작업 수행시
  - 해당페이지는 별도의 공간으로 복제

### 계층적 페이지
- 프로세스 테이블 크기 생각보다 큼
- PTE 모두 메모리에 두는 것은 낭비
- 페이지 테이블을 페이징 하여 여러 단계의 페이지를 두는 방식
- 페이지 테이블을 쪼개고 페이지를 가리키는 Outer page table 을 두는 방식
  - outer page 는 메모리에 적재 (cpu 와 가장 가까이 위치한 페이지 테이블)
  - 그리고 필요한 하위 페이지 테이블만 메모리에 적재
- outerpage 번호 / 하위 page 번호 / offset
  - 바깥 페이지 번호를 통해 페이지 테이블의 페이지 찾기
  - 페이지 테이블의 페이지를 통해 프레임 번호 찾고 변위 더함 -> 물리주소 얻기

![img src](https://user-images.githubusercontent.com/49462767/226159117-06852bdc-51e9-4ecc-9dc8-51e4955cb2d7.png)

- 위의 예시는 두단계 계층이지만 3단계 4단계가 될수도 있음
- 단계가 높다고 다 좋은것은아님
  - 페이지 fault interrupt 가 발생했을 경우 그만큼 메모리 참조를 많이 해야함

## 14-3 페이지 교체와 프레임 할당

> 페이징이 제한된 자원을 효율적으로 사용하게 하였으나 무작정 물리 메모리보다 큰 작업들을 탈없이 실행 시키는 것은 아님

- 기존 적재된 불필요한 페이지를 선별해 보조기억 장치로 내보내기
- 프로세스들에게 적절한 수의 페이지 할당하기

### 요구 페이징
- 필요한 페이지만을 메모리에 적재함
  - 페이지 교체
  - 프레임 할당

- 순수 요구 페이징
  - 아무런 페이지도 메모리에 적재하지 않은채 그냥 실행
  - 첫번째 명령어를 실행하는 순간부터 page fault 발생

### 페이지 교체 알고리즘
- 어떤 페이지를 내보낼까?
- 무엇이 좋은 페이지 교체 알고리즘?
  - page fault 가 적은 알고리즘
  - 보조기억장치로 내쫓을 페이지를 잘고르는 알고리즘
    - page fault 발생하면 보조기억장치에 접근해야해서 성능 저하
- 페이지 fault 횟수는 어떻게 아는가?
  - 페이지 참조열 (page reference string)
  - cpu 가 참조하는 페이지들 중 연속된 페이지 생략
- FIFO 페이지 교체 알고리즘
  - 오래 머물렀다면 나가라
  - 가장 단순함
  - 프로그램 실행 내내 사용될 페이지라면?
    - 먼저 적재되었다고 내쫓으면 크리티컬 할 수 있음
- FIFO (second-chance) 교체 알고리즘
  - 참조 비트 1 : cpu 한번 참조 한적 있음 
    - 오래 머물러있었지만 cpu 가 참조한적이 있다면 참조비트 0으로 변경후 적재 시간을 현재 시간으로 설정
  - 참조 비트 0 : cpu 참조한적 없음
    - 오래 머물러있었지만 참조한적 없을 경우 내쫓음
- 최적 페이지 교체 알고리즘
  - cpu에 의해 참조하는 횟수를 고려
  - 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
  - 사용빈도가 가장 낮을 페이지를 교체하는 알고리즘
  - 가장 낮은 페이지 폴트율을 보장
  - 실제 구현이 어려움

- LRU (least recently used) 페이지 교체 알고리즘
  - 최적 페이지 교체 알고리즘 과 조금 다름 (앞으로의 상황을 예측해야함)
  - 지금까지 가장 오래 사용되지 '않은' 페이지 교체 (예측이 아님)
- 기타 페이지 교체 알고리즘


### 스래싱과 프레임 할당
- 페이지 폴트가 자주 발생하는 이유
  - 나쁜 페이지 교체 알고리즘을 사용
  - 프로세스가 사용할 수 있는 프레임 자체가 적음

### 스래싱
  - 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요 (CPU 이용율 저해)
  - 동시 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지는것 아님


![img src](https://user-images.githubusercontent.com/49462767/226162997-b002f7ef-1871-44a4-96e3-a061562680ed.png)

- 멀티 프로그램이 많을 수록 cpu 이용률이 계속해서 늘어나는 것은 아님
- 어느 순간부터 급격하게 낮아지고 페이징에 더 오랜 시간이 걸림 (스래싱)


- 왜 스래싱이 발생??
  - 각 프로세스가 필요로 하는 최소한의  프레임 수가 보장되지 않음
  - 운영체제는 각각의 프로세스가 필요로하는 최소 프레임 파악, 적당히 할당 해야함

### 프레임 할당

### 정적 프레임 할당 방식
- 균등 할당 (equal allocation)
  - 모든 프로세스들에게 균등하게 1/n 으로 할당하는 방식
- 비례 할당 (proportional allocation)
  - 프로세스 크기에 비례하여 프레임 할당
  - 막상 실행을 해보면 다를 수 있음
  - 실제로 실행해봐야 알 수 있음


### 동적 프레임 할당 방식

- 작업 집합 모델 (working set model) 할당방식
  - 프로세스 실행 과정중에서 배분할 프레임 결정
  - cpu가 특정 시간동안 주로 참조한 페이지 개수만큼만 프레임 할당
    - 특정시간동안 몇몇개의 페이지를 참조함
    - 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지
  - 그러므로 작업 집합 이란?
    - 실행중인 프로세스가 일정 시간동안 참조한 페이지의 집합
  - 작업집합 구하기?
    - 프로세스가 참조한 페이지
    - 시간 간격 필요
      - 일정한 시간 간격 에 프로세스가 참조한 페이지의 총 값만큼 할당!

<br>

- 페이지 폴트 빈도 based 할당방식
  - 이 방식 또한 프로세스 실행 과정에서 배분할 프레임 결정한다
  - 핵심아이디어는 이러하다
    - 페이지 폴트율이 너무 높으면 적은 프레임을 가지고있음 (상한선)
    - 페이지 폴트율이 너무 낮으면 너무 많은 프레임을 가지고있음 (하한선)
  
![img src](https://user-images.githubusercontent.com/49462767/226163997-99642410-1c3c-4c5f-ae0e-4063d0b9bd23.png)




