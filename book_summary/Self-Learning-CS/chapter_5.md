# 5. CPU 성능 향상 기법

- 클럭
- 코어
- 스레드
- 멀티 코어
- 멀티 스레드
---
## 5-1 빠른 CPU를 위한 설계기법

### 클럭
- 클럭 속도가 높은 CPU 는 일반적으로 성능이 좋다 (CPU 속도 단위)
- 클럭 속도 HZ 단위로 측정
- 실제 CPU 클럭 속도 2.5GHz(BASE), 4.9GHz(MAX) / 기가 헤르츠 단위이다
- 클럭속도는 일정하지 않음
  - 고성능 필요할때 순간적으로 클럭속도 높임
  - (overclocking)
  - 게임 하거나 고사양 작업중 발열이 되는것이 예시이다
  - clock 속도를 높이는게 cpu 성능 개선에 한계가 있음

### 코어 & 멀티 코어

- 코어를 이해하려면 현대적 관점에서 CPU 를 재해석 해야함
  - 고전적인 CPU 는 명령어를 실행하는 부품은 하나만 존재했음
  - 현대사회에선 여러개 만들 수 있음 (듀얼코어, 쿼드코어, 8core)
- 현대사회에서 CPU 는 명령어 실행하는 부품을 '여러 개' 포함하는 부품 이란 뜻
  - 멀티코어 CPU, 멀티코어 프로세서
  - 코어의 개수에 비례해서 성능이 증가하진 않음 (조별 과제를 생각해보라)

### 스레드 & 멀티 스레드

- 스레드: 실행 흐름의 단위
    - 하드웨어적 스레드
      - 하나의 코어가 동시에 처리하는 명령어 단위
    - 소프트웨어적 스레드
      - 하나의 프로그램에서 독립적으로 실행되는 단위

- 멀티 스레드 : 하나의 코어로 여러 명령어 동시에 처리
- 멀티 스레드 프로세서 (하드웨어)
  - 핵심은 레지스터
  - 하나의 명령어를 처리할 레지스터를 여러개 가지고 있으면 된다
  - 2 코어 4 스레드는 프로그램 입장에서 봤을때 4개의 cpu 가 있는 것 처럼 보임
    - 논리 프로세서는 4개인 것
---
## 5-2 명령어 병렬 처리 기법

- cpu 가 놀지 않고 작동시키는 기법
- 명령어 병렬 처리 기법 (ILP Instruction Level Parallelism)
  - 명령어 파이프라이닝
  - 슈퍼 스칼라
  - 비순차적 명령어 처리


### 명령어 파이프라인

이 단계가 정답은 아니다

**각 단계만 겹치지 않는다면 각 단계를 동시에 실행할 수 있음**
- 명령어 인출
- 명령어 해석
- 명령어 실행
- 결과 저장

![img src](https://user-images.githubusercontent.com/49462767/224881114-e808b6e6-4b50-47d6-aeb5-b622af9294c7.png)

- 명령어 파이프라이닝
  - 컨베이어 벨트처럼 파이프라인에 넣고 동시에 처리하는 기법

### 명령어 파이프라인 의 위험

- 파이프라인 위험
  - 데이터 위험
    - 데이터 의존성에 의해 발생
  - 제어 위험
    - 프로그램 카운터의 갑작스러운 변화
    - 실행 중인 명령어의 다음 주소 로 갱신
      - 실행흐름 바뀌면 처리중이였던 명령어 무쓸모
  - 구조적 위험
    - 서로 다른 명령어가 동시에 ALU, CPU 부품 사용하려고 할 때 발생

### 슈퍼 스칼라
- 여러개의 명령어 파이프라인을 포함한 구조

![img src](https://user-images.githubusercontent.com/49462767/224882206-1bacc858-198b-407e-8632-ef469b4e2216.png)


### 비순차적 명령어 처리 (OoOE: Out of order execution)

- 합법적 새치기
- 데이터 의존성이 전혀없는 순서를 바꿔 처리해도 수행 결과에 영향 미치지 않는 명령어 존재
- CPU 는 이 의존성을 판단할 수 있어야 함


## 5-3 CISC 와 RISC
- ISA
- CISC
- RISC


### 명령어 집합 구조 (ISA)

- 세상엔 cpu의 종류가 다양하고 저마다 명령어 집합이 다름
- 명령어 집합 구조 (Instruction Set Architecture, ISA) 가 다름
  - cpu 가 어떤 명령어를 이해하는지에 따라 컴퓨터 구조 및 설계방식 다름
  - x86-64 ISA, ARM-ISA
- 이로인해 같은 소스 코드라도  ISA 가 다르면 CPU 가 이해할 수 있는 명령어, 어셈블리어도 달라짐

![img src](https://user-images.githubusercontent.com/49462767/224888250-d9ddeb84-45df-4c34-8615-30060490b45a.png)

- ISA 는 일종의 CPU 언어 라고 볼 수 있음

### CISC

- Complex Instruction Set Computer
  - x-86-64
- 명령어 형태와 크기가 다양한 '가변 길이 명령어' 사용
- 적은 수의 명령어로 프로그램 실행 가능
- 메모리를 아까며 개발했던 시기에 인기가 높았음

### CISC 단점
- 명령어 길고 복잡 -> 여러 클럭 주기 필요
- 실행되기까지의 시간이 일정하지 않음 -> 파이프라이닝 어려움
- 대다수의 복잡한 명령어는 사용빈도가 낮음


### RISC

- Reduced Instruction Set Computer
  - ARM
  - CISC 가 준 교훈
    - 명령어 파이프라인을 최대한 활용해야한다
    - 명령어 길이와 수행 시간이 짧고 규격화 되어있어야함
    - 어짜피 자주 쓰이는 명령어만 사용됨
    - 자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것
- RISC 는 명령어의 종류가 적다
  - 하지만 1클럭 내외로 실행되는 명령어 지향한다
- RISC 는 고정 길이 명령어를 사용

- 메모리 접근 단순화, 최소화 (load-store 구조)
  - CISC 보다 주소 지정 방식 종류가 적음
- 레지스터 적극적으로 활용
  - 범용 레지스터 갯수도 더 많다