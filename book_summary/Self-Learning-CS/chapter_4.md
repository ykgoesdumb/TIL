# 4. CPU의 작동원리

## 4-1 ALU와 제어장치

- ALU 는 레지스터를 통해 '피연산자' 를 받아들이고 제어장치로부터 '제어신호'를 받아들임
- 받아들인 피연산자와 제어신호로, 산술연산 논리연산 등 다양한 연산을 함
- 연산한 결괏값, 플래그를 ALU 는 내보냄

- ALU 가 내보낸 결과값은 임시적으로 레지스터에 저장
- 플래그를 내보냄
  - 음수 양수 플래그가 전부가 아니다

### 플래그

플래그 레지스터에 저장

- 부호 플래그 : 1 인경우 음수 0 인경우 양수
- 제로 플래그 : 1 인경우 0, 0 인경우 0이 아님
- 캐리 플래그 : 1 인경우 올림, 빌림수 발생
- 오버플로우 플래그 : 오버플로우 발생 유무
  - 오버플로우: 연산 결과가 연산결과를 담을 레지스터보다 큰 상황
- 인터럽트 플래그 : 인터럽트 가능한지 아닌지?
- 슈퍼바이저 플래그 : 커널모드 실행중 = 1, 사용자모드 실행중 = 0

### 제어 장치

1. 제어장치는 clock 신호를 받아들임
2. 제어장치는 해석해야 할 명령어를 받아들임
  - cpu가 해석해야될 명령어는 '명령어 레지스터' 에 저장
3. 제어장치는 플래그 레지스터 속 플래그 값 받아들임
4. 제어장치는 시스템 버스, 그중에서 제어버스로 전달된 제어 신호를 받아들임
   - 제어신호는 CPU 뿐만아니라 입출력장치도 '제어 버스' 를 통해 전달 가능

- 제어장치는 CPU 내,외부로 제어 신호를 보냄

## 4-2 레지스터

레지스터를 잘 관찰하면 프로그램의 자세한 실행 과정을 알 수 있음

### 반드시 알아야할 레지스터

- 프로그램 카운터
  - (명령어 포인터)Instruction pointer, 읽어들일 명령어의 주소 저장
  - 명령어 주소를 읽었으면 프로그램 카운트 1 증가 -> 다음 작업 수행
- 명령어 레지스터
  - 방금 읽어들인 명령어를 저장
  - 제어장치는 명령어 레지스터속 명령어 해석 뒤 제어신호 내보냄
- 메모리 주소 레지스터
  - 메모리의 주소 저장, CPU 읽고자 하는 주소값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침
- 메모리 버퍼 레지스터
  - MDR (memort data register), 메모리와 주고 받을 값 을 저장



- 범용 레지스터
  - 다양하고 일반적인 상황에서 자유롭게사용, 데이터 주소값 다 저장
- 플래그 레지스터
  - 앞에서 설명함
- 스택 포인터
  - 스택 주소 지정 방식
  - 스택 + 스택 포인터
  - 스택포인터: 스택의 꼭대기를 가리키는 레지스터
  - 스택: 메모리 안에 스택처럼 사용할 영역이 정해져 있음 (스택 영역)

- 베이스 레지스터
 - 변위 주소 지정방식 : 명령어중 오퍼랜드의 값과 특정 레지스터 값을 더하여 유효주소 알아내는 방법
   - 상대 주소 지정방식
     - 오퍼랜드 + 프로그램 카운터 = 유효주소
     - 모든코드를 실행하는 것이 아닌, 분기, 특정 주소 코드 실행할 때 사용
   - 베이스 레지스터 지정방식
     - 오퍼랜드 + 베이스 레지스터 = 유효주소
     - 베이스 레지스터 역할 = 기준주소
     - 오퍼랜드 역할 = 기준주소로부터 이격 거리


## 4-3 명령어 사이클과 인터럽트

인터럽트: CPU가 정해진 흐름에 따라 명령어를 처리하다가 끊기는 상황

### 명령어 사이클
- 각각의 명령어들 일정한 주기 반복되면서 실행
  - 인출 사이클 (메모리 -> cpu)
  - 실행 사이클
  - 간접사이클 (간접 주소 지정방식의 경우 메모리에 접근 한번 더해야함)
  - 인터럽트 사이클


### 인터럽트
- 동기 인터럽트 (예외)
  - cpu 에의해 발생하는 인터럽트 , exception
- 동기 인터럽트 종류
  - fault : 예외를 처리한 직후 '예외가 발생한 명령어부터' 실행을 재개하는 예외
  - trap : 예외를 처리한 직후 '예외가 발생한 명령어 다음 명령어부터' 실행을 재개하는 예외
  - abort : 강제로 중단시킬 수 밖에 없는 심각한 오류
  - software interrupt : 시스템 호출 발생하였을 경우

- 비동기 인터럽트
  - 입출력장치에 의해 주로 발생
    - 전자레인지 조리 완료(?)
    - 알림
    - 주기적으로 cpu 가 확인할 필요없음, 알림 오기 전까지 다른 작업 가능
  - 하드웨어 인터럽트


### 하드웨어 인터럽트 처리 순서

1. 입출력장치 -> cpu 인터럽트 요청 신호
2. cpu 는 실행 사이클 끝나고 명령어 인출 전 '인터럽트 여부' 항시 체크
3. 인터럽트 플래그를 통해 현재 인터럽트 받아들일 수 있는지 여부 확인
4. 인터럽트 받아들일 수 있다면 cpu는 지금까지의 작업을 백업
5. '인터럽트 벡터' 를 참조 하여 '인터럽트 서비스 루틴' 실행
6. '인터럽트 서비스 루틴' 끝나면 백업한 작업 복구 후 실행 재개


- cpu 중요한 작업 중 이라면 인터럽트 플래그 '불가능' -> cpu는 인터럽트 요청 와도 무시함
- 인터럽트 서비스 루틴: 인터럽트 처리하기위한 프로그램 (인터럽트 핸들러)
- 인터럽트 벡터 : 인터럽트 서비스 루틴을 구별하기 위한 정보
- 인터럽트 요청이들어와서 백업할때 '스택' 에 백업
- 못막는 인터럽트도 있음