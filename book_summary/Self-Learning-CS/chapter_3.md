# 3. 명령어

## 3-1 소스 코드와 명령어

### 모든 소스 코드는 컴퓨터 냅에서 명령어로 변환됨

### 언어의 레벨

- 고급 언어 
  - 사람이 이해하고 작성하기 쉽게 만들어진 언어
- 저급 언어
  - 컴퓨터가 직접 이해하고 실행할 수 있는 언어

- 고급언어로 작성된 소스코드가 실행되려면 저급언어로 변환 되어야함
  
- 저급언어
  - 기계어
    - 0과 1의 명령어 비트로 이루어진 언어
  - 어셈블리어
    - 읽기 편한 형태로 번역한 저급 언어
    - 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 영역에서 많이 사용한다
      - 임베디드 개발, 게임 개발, 정보 보안 분야
    - 컴퓨터의 실행과정을 추적하고 관찰할 수 있음

### 컴파일 언어와 인터프리터 언어

고급언어를 저급언어로 변환하는 방식

- 컴파일 언어
  - 컴파일러에 의해 소스코드 전체가 저급 언어로 변환되어 실행되는 고급언어
    - C 언어
    - 컴파일러는 문법적인 오류 ㅇ벗는지, 실행 가능한 코드인지, 불필요한 코드는 없는지, 소스코드 내 오류 하나라도 발견시 컴파일 실패
    - 컴파일러로 변환된 코드 'object code' 목적 코드
- 인터프리터 언어
    - 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 언어
    - python
    - 소스 코드 전체를 저급 언어로 변환하는 시간 기다릴 필요 없음
    - N 번째 줄에 문법 오류가 있더라도 N-1 번째 줄까지 실행함
    - 일반적으로 인터프리터 언어는 컴파일 언어보다 느림

- 현대의 프로그래밍 언어에선 컴파일과 인터프리터 의 경계가 모호한 부분이 많음
  - python 도 compile 을 실행함
  - java의 경우 저급언어로 변환 과정에 compile 과 interpret 을 동시 수행함


### 목적파일 과 실행파일

- 목적코드로 이루어진 파일을 목적파일 이라고 부름
  - 목적 파일과 실행 파일은 같은 의미가 아님
  - linking 이라는 프로세스 거쳐야함
  - 예를들면,
    - 라이브러리를 불러오는 코드를 실행했을때 목적코드는 그 라이브러리에 담긴 의미를 모름
    - 그 라이브러리와 소스코드를 링킹해주는 작업이 필요함


---

## 3-2 명령어의 구조

### 연산 코드와 오퍼랜드

명령어의 구조는 연산 코드와, 오퍼랜드로 되어있음
- opration code(연산코드)
  - 명령어가 수행할 연산

- operand
  - 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치

- 기계어와 어셈블리 언어또한 명령어 이므로 연산코드와 오퍼랜드로 구성되어있음

#### 오퍼랜드
- 주소필드라고 부르기도 한다
- 사용할 데이터를 직접 명시하기보단 데이터가 저장된 위치를 명시함
- 연산에 사용할 데이터가 저장된 위치, 메모리 주소, 레지스터 이름 담김
    - 0-주소명령어
    - 1-주소명령어
    - ... 3- 주소 명령어

#### 연산코드
- 연산코드, 종류 는 CPU 마다 다르지만 대표적인 것들은 아래와 같다

  - 데이터 전송
    - MOVE : 데이터를 옮겨줘
    - STORE : 메모리에 저장해줘
    - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와줘
    - PUSH : 스택에 데이터를 저장해줘
    - POP : 스택의 최상단 데이터를 가져와줘


  - 산술/논리 연산
    - ADD SUBTRACT MULTIPLY DIVIDE
    - INCREMENT DECREMENT 오퍼랜드에 1을 더해줘/ 오퍼랜드에 1을 빼줘
    - AND /OR / NOT 
    - COMPARE 두개의 숫자 또는 TRUE FALSE 를 비교하라

  - 제어 흐름 변경
    - JUMP : 특정 주소로 실행 순서를 옮겨줘
    - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨줘
    - HALT : 프로그램 실행을 멈춰줘
    - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨줘
    - RETURN : CALL 을 호출할떄 저장했던 주소로 돌아가줘
  - 입출력 제어
    - READ : 특정 입출력 장치로부터 데이터를 읽어줘
    - WRITE : ~~~~~써줘
    - START IO : 입출력 장치를 시작해줘
    - TEST IO : 입출력 장치의 상태를 확인해줘

### 주소 지정 방식

주소 지정 방식이란? 유효 주소를 찾는 방법 

- 오퍼랜드의 필드 길이는 (전체 명령어 비트 - 연산 코드 길이)
- 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커짐
    - effective address(유효 주소): 연산의 대상이 되는 데이터가 저장된 위치


### 주소 지정 방식의 종류

- 즉시 주소 지정 방식 (immediate addressing mode)
  - 가장 간단, 데이터를 오퍼랜드 필드에 직접 명시
  - 표현할 수 있는 데이터의 크기는 작아지나 가장 빠름
- 직접 주소 지정 방식 (direct addressing mode)
  - 유효 주소를 직접적으로 명시
- 간접 주소 지정 방식
  - 메모리안에 유효 주소가 저장되어있음, 그 유효 주소의 주소를 명시하는 방식
  - 두번의 메모리 접근이 필요
  - 앞의 두 방식보다 느림
  - 유효 주소의 범위 넓음

- 레지스터 주소 지정 방식
  - 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
  - 직접 주소 방식보다 (레지스터가) CPU 내부에 있으므로 빠르게 데이터에 접근 가능
  - 표현할 수 있는 레지스터 크기에 제한 (직접 주소 지정 방식과 비슷한 한계점)

- 레지스터 간접 지정 방식
  - 간접 주소 지정 방식과 흡사하나 메모리에 접근횟숙 한 번으로 줄어듬



각 방식 별 오퍼랜드에 명시하는 값
- 즉시 주소 : 연산에 사용할 데이터
- 직접 주소 : 유효 주소 (메모리 주소)
- 간접 주소 : 유효 주소의 주소
- 레지스터 주소 : 유효 주소 (레지스터 이름)
- 레지스터 간접 주소 : 유효 주소를 저장한 레지스터


### 스택과 큐

- Stack
  - 한쪽 끝이 막혀있는 통 같은 자료구조
  - LIFO (LAST IN FIRST OUT) 후입선출
  - 1 - 2 - 3 - 4 - 5 로 들어갔다면 역순으로 꺼내짐
  - PUSH 는 새로운 데이터 저장 POP 은 스택에 저장된 데이터 꺼내기
- QUEUE
  - 양쪽이 뚫려있는 통 같은 자료구조
  - FIFO
  - 먼저 저장한 순서대로 데이터를 빼냄

